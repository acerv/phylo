/* Generated By:JavaCC: Do not edit this line. CostsParser.java */
package parser.set.langcosts;

import parser.set.langcosts.table.Cost;
import parser.set.langcosts.table.CostsException;
import parser.set.langcosts.table.Parameter;
import parser.set.langcosts.table.CostsTable;
import parser.set.langcosts.table.ParametersSet;
import informations.Infos;
import java.io.*;
import parser.set.langrules.tree.OperationNode;
import parser.set.langrules.tree.ParameterNode;
import parser.set.langrules.tree.RuleNode;
import parser.set.langrules.tree.RuleTree;
import java.util.ArrayList;
import parser.set.declare.LanguageInformations;
import java.util.Arrays;

public class CostsParser implements CostsParserConstants {
    static ArrayList<String> alp;
    static ArrayList<String> undef = new ArrayList<String>();
    static int p;
    public static FileReader reader;

    public static ParametersSet parse(LanguageInformations infos, String filename)
        throws NumberFormatException, ParseException, CostsException, IOException
    {
        alp = infos.getAlphabet();
        undef.addAll(Arrays.asList(Infos.UNDEFINED_CHARACTERS));
        p = infos.getParameters();

        ParametersSet set = null;
        reader = new FileReader(filename);
        CostsParser parser = new CostsParser( reader );
        set = parser.Start();
        reader.close();

        return set;
    }

  final public ParametersSet Start() throws ParseException, NumberFormatException, ParseException, CostsException {
    ParametersSet set;
    Parameter param;
    ArrayList<Cost> defaultCosts = new ArrayList<Cost>();
    CostsTable table;
    jj_consume_token(DEF);
    jj_consume_token(ARROW);
    Costs(defaultCosts);
        // get global default costs
        table = new CostsTable(alp, true);

        for(int i = 0; i < defaultCosts.size(); i++)
            table.addElement(defaultCosts.get(i));

        set = new ParametersSet(p, table);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PAR:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      param = ParamCosts(p);
            set.add(param);
    }
    jj_consume_token(0);
      {if (true) return set;}
    throw new Error("Missing return statement in function");
  }

  final public Parameter ParamCosts(int k) throws ParseException, NumberFormatException, ParseException, CostsException {
    Parameter param = null;
    CostsTable table = null;
    RuleTree tree = null;

    ArrayList<CostsTable> tabSet = new ArrayList<CostsTable>();
    ArrayList<Cost> costs = new ArrayList<Cost>();

    Token t;
    int value;
    jj_consume_token(PAR);
    t = jj_consume_token(NUMBER);
    jj_consume_token(OPEN_BRACKET);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PAR:
      case DEF:
      case OPEN:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PAR:
      case OPEN:
        // Normal case
                    tree = Rule(k);
        jj_consume_token(ARROW);
                      costs.clear();
        Costs(costs);
                    table = new CostsTable(alp, false);
                    table.addRuleTree(tree);

                    for(int i = 0; i < costs.size(); i++)
                        table.addElement(costs.get(i));

                    tabSet.add(table);
        break;
      case DEF:
        jj_consume_token(DEF);
        jj_consume_token(ARROW);
                      costs.clear();
        Costs(costs);
                    table = new CostsTable(alp, true);

                    for(int i = 0; i < costs.size(); i++)
                        table.addElement(costs.get(i));

                    tabSet.add(table);
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(CLOSE_BRACKET);
        value = Integer.parseInt(t.image);
        param = new Parameter(k, value, tabSet);

        {if (true) return param;}
    throw new Error("Missing return statement in function");
  }

// Returns tree of rules for costs
  final public RuleTree Rule(int k) throws ParseException, NumberFormatException, ParseException {
    RuleTree tree;
    RuleNode n;
    n = Formula();
            tree = new RuleTree(k,n);
            //System.out.println("Created rule tree");

      {if (true) return tree;}
    throw new Error("Missing return statement in function");
  }

  final public RuleNode Formula() throws ParseException, NumberFormatException, ParseException {
    RuleNode n1,n2,n;
    OperationNode par;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN:
      jj_consume_token(OPEN);
      n1 = Formula();
      jj_consume_token(CLOSE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        jj_consume_token(AND);
        n2 = Formula();
                n = new OperationNode();
                par = (OperationNode) n;
                par.setAsAndNode();
                par.setLeftChild(n1);
                par.setRightChild(n2);
        break;
      case OR:
        jj_consume_token(OR);
        n2 = Formula();
                n = new OperationNode();
                par = (OperationNode) n;
                par.setAsOrNode();
                par.setLeftChild(n1);
                par.setRightChild(n2);
        break;
      default:
        jj_la1[3] = jj_gen;
                {if (true) return n1;}
      }
      break;
    case PAR:
      n1 = Param();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        jj_consume_token(AND);
        n2 = Formula();
                n = new OperationNode();
                par = (OperationNode) n;
                par.setAsAndNode();
                par.setLeftChild(n1);
                par.setRightChild(n2);
        break;
      case OR:
        jj_consume_token(OR);
        n2 = Formula();
                n = new OperationNode();
                par = (OperationNode) n;
                par.setAsOrNode();
                par.setLeftChild(n1);
                par.setRightChild(n2);
        break;
      default:
        jj_la1[4] = jj_gen;
                n = n1;
      }
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  final public ParameterNode Param() throws ParseException, NumberFormatException, ParseException {
    ParameterNode n;
    Token t1,t2;
    int k;
    String c;
    jj_consume_token(PAR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ZERO:
      t1 = jj_consume_token(ZERO);
      break;
    case NUMBER:
      t1 = jj_consume_token(NUMBER);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(POINT);
    t2 = jj_consume_token(VALUE);
        if(!alp.contains(t2.image) && !undef.contains(t2.image))
            {if (true) throw new ParseException("alphabet doesn't contain '"+t2.image+"' character");}

        k = Integer.parseInt(t1.image);
        c = t2.image;
        n = new ParameterNode(k,c);
        {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

/* Gets the costs of assignment
 * self is true when this function have to get the cost of self assignment
 */
  final public void Costs(ArrayList<Cost> costs) throws ParseException, NumberFormatException, ParseException, CostsException {
    Token t;
    ArrayList<String> a = null;
    ArrayList<String> b = null;
    int cost;
    jj_consume_token(OPEN);
    a = Characters();
    jj_consume_token(COMMA);
    b = Characters();
    jj_consume_token(CLOSE);
    jj_consume_token(COST);
    t = jj_consume_token(NUMBER);
        cost = Integer.parseInt(t.image);

        // Control over the characters
        if(a.size() == 1 && b.size() == 1)
        {
            costs.add(new Cost(a.get(0), b.get(0), cost));
        }
        else
        {
            // Cost from character to same one is 0 by default
            for(int i = 0; i < a.size(); i++)
            {
                for(int j = 0; j < b.size(); j++)
                {
                    if(a.get(i).equals(b.get(j)))
                        continue;
                    else
                        costs.add(new Cost(a.get(i), b.get(j), cost));
                }
            }
        }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      Costs(costs);
      break;
    case EOL:
      jj_consume_token(EOL);
         ;
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public ArrayList<String> Characters() throws ParseException, NumberFormatException, ParseException {
    Token t;
    ArrayList<String> a = new ArrayList<String>();
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ZERO:
      case VALUE:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VALUE:
        t = jj_consume_token(VALUE);
                if(!alp.contains(t.image) && !undef.contains(t.image))
                    {if (true) throw new ParseException("alphabet doesn't contain '"+t.image+"' character");}

                a.add(t.image);
        break;
      case ZERO:
        t = jj_consume_token(ZERO);
                if(!alp.contains(t.image) && !undef.contains(t.image))
                    {if (true) throw new ParseException("alphabet doesn't contain '"+t.image+"' character");}

                a.add(t.image);
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return a;}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public CostsParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[10];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x100,0x20900,0x20900,0x3000,0x3000,0x20100,0x1400000,0x280000,0xc00000,0xc00000,};
   }

  /** Constructor with InputStream. */
  public CostsParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public CostsParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new CostsParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public CostsParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new CostsParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public CostsParser(CostsParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(CostsParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[25];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 10; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 25; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
